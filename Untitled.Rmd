---
title: "R Programming Language"
author: "Anup Kumar"
date: "18/05/2021"
output: html_document
---

# Some of the best features of R are:

* It's free, open source, and available on every major platform. As a result, if 
  you do your analysis in R, anyone can easily replicate it, regardless of 
  where they live or how much money they earn.

  
* A massive set of packages for statistical modelling, machine learning,
  visualisation, and importing and manipulating data. Whatever model or
  graphic you're trying to do, chances are that someone has already tried
  to do it and you can learn from their efforts.

* Powerful tools for communicating your results. [RMarkdown][rmarkdown] makes
  it easy to turn your results into HTML files, PDFs, Word documents,
  PowerPoint presentations, dashboards and more. [Shiny][shiny] allows you to
  make beautiful interactive apps without any knowledge of HTML or javascript.

* RStudio, [the IDE](http://www.rstudio.com/ide/), provides an integrated
  development environment, tailored to the needs of data science, interactive 
  data analysis, and statistical programming.

* Cutting edge tools. Researchers in statistics and machine learning will often
  publish an R package to accompany their articles. This means immediate
  access to the very latest statistical techniques and implementations.

* Deep-seated language support for data analysis. This includes features
  like missing values, data frames, and vectorisation.

* A strong foundation of functional programming. The ideas of functional
  programming are well suited to the challenges of data science, and the 
  R language is functional at heart, and provides many primitives needed
  for effective functional programming.
  

* The ease with which R can connect to high-performance programming languages 
  like C, Fortran, and C++.

* R is a dynamic programming language, which means R automatically interprets your code as you run it. R can be used as a calculator.

# Generating Sequence in R
 An important way of creating vectors is to generate a sequence of numbers. The simplest sequences are in steps of 1, and the colon operator is the simplest way of generating such sequences. All you do is specify the first and last values separated by a colon. Here is a sequence from 0 up to 10:



```{r}
0:10;15:5
```


To generate a sequence in steps other than 1, you use the seq function. There are various forms of this, of which the simplest has three arguments: from, to, by (the initial value, the final value and the increment). If the initial value is smaller than the final value, the increment should be positive, like this:



```{r}
seq(from=0, to=1.5, by=0.1)
seq(6,4,-0.2)
seq(from=0.04,by=0.01,length=11)
N <- c(55,76,92,103,84,88,121,91,65,77,99)
seq(0.04,by=0.01,along=N)
```
An important application of the last option is to get the x values for drawing smooth lines through a scatterplot of data using predicted values from a model.

If you want a vector made up of sequences of unequal lengths, then use the sequence function. Suppose that most of the five sequences you want to string together are from 1 to 4, but the second one is 1 to 3 and the last one is 1 to 5, then:

```{r}
sequence(c(4,3,4,4,4,5))
```




## Generating repeats
 
You will often want to generate repeats of numbers or characters, for which the function is rep. The object that is named in the first argument is repeated a number of times as specified in the second argument. At its simplest, we would generate five 9s like this:
```{r}
rep(9,5)
rep(1:4,2)
rep(1:4, each=2)
rep(1:4, each=2, times=3)
rep(1:4,1:4)
rep(1:4,c(4,1,4,2))
rep(c("cat","dog","gerbil","goldfish","rat"),c(2,3,2,1,3))
```





## Objects
R lets you save data by storing it inside an R object. What’s an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:

* To create an R object, choose a name and then use the less-than symbol, <, followed by a minus sign, -, to save data into it. This combination looks like an arrow, <-. R will make an object, give it your name, and store in it whatever follows the arrow.

*  When you ask R what’s in a, it tells you on the next line.

* You can use your object in new R commands, too. Since a previously stored the
value of 1, you’re now adding 1 to 2.

* R also understands capitalization (or is case-sensitive), so name and Name will refer to different objects.





#Names in R
R has strict rules about what constitutes a valid name. A  name must consist of letters[^letters], digits, `.` and `_` but can't begin with `_` or a digit. Additionally, you can't use any of the __reserved words__ like `TRUE`, `NULL`, `if`, and `function` (see the complete list in `?Reserved`). A name that doesn't follow these rules is a __non-syntactic__ name; if you try to use them, you'll get an error:
```{r, eval = FALSE}
_abc <- 1
#> Error: unexpected input in "_"
if <- 10
#> Error: unexpected assignment in "if <-"
```

[^letters]: Surprisingly, precisely what constitutes a letter is determined by your current locale. That means that the syntax of R code can actually differ from computer to computer, and that it's possible for a file that works on one computer to not even parse on another! Avoid this problem by sticking to ASCII characters (i.e. A-Z) as much as possible.

It's possible to override these rules and use any name, i.e., any sequence of characters, by surrounding it with backticks:

```{r}
`_abc` <- 1
`_abc`
`if` <- 10
`if`
```

While it's unlikely you'd deliberately create such crazy names, you need to understand how these crazy names work because you'll come across them, most commonly when you load data that has been created outside of R.


# Vectors




## Vector basics

There are two types of vectors:

1.  **Atomic** vectors, of which there are six types: **logical**, **integer**, **double**, **character**, **complex**, and **raw**.
    Integer and double vectors are collectively known as **numeric** vectors.

2.  **Lists**, which are sometimes called recursive vectors because lists can contain other lists.

The chief difference between atomic vectors and lists is that atomic vectors are **homogeneous**, while lists can be **heterogeneous**.
There's one other related object: `NULL`.
`NULL` is often used to represent the absence of a vector (as opposed to `NA` which is used to represent the absence of a value in a vector).
`NULL` typically behaves like a vector of length 0.
#Figure \@ref(fig:datatypes) summarises the interrelationships.

```{r datatypes, echo = FALSE, out.width = "50%", fig.cap = "The hierarchy of R's vector types"}
 knitr::include_graphics("diagrams/data-structures-overview.png")
 ```

Every vector has two key properties:

1.  Its **type**, which you can determine with `typeof()`.

    ```{r}
    typeof(letters)
    typeof(1:10)
    ```

2.  Its **length**, which you can determine with `length()`.

    ```{r}
    x <- list("a", "b", 1:10)
    length(x)
    ```

Vectors can also contain arbitrary additional metadata in the form of attributes.
These attributes are used to create **augmented vectors** which build on additional behaviour.
There are three important types of augmented vector:

-   Factors are built on top of integer vectors.
-   Dates and date-times are built on top of numeric vectors.
-   Data frames and tibbles are built on top of lists.

This chapter will introduce you to these important vectors from simplest to most complicated.
You'll start with atomic vectors, then build up to lists, and finish off with augmented vectors.

## Important types of atomic vector

The four most important types of atomic vector are logical, integer, double, and character.
Raw and complex are rarely used during a data analysis, so I won't discuss them here.

### Logical

Logical vectors are the simplest type of atomic vector because they can take only three possible values: `FALSE`, `TRUE`, and `NA`.
Logical vectors are usually constructed with comparison operators, as described in [comparisons].
You can also create them by hand with `c()`:

```{r}
1:10 %% 3 == 0

c(TRUE, TRUE, FALSE, NA)
```

### Numeric

Integer and double vectors are known collectively as numeric vectors.
In R, numbers are doubles by default.
To make an integer, place an `L` after the number:

```{r}
typeof(1)
typeof(1L)
1.5L
```

The distinction between integers and doubles is not usually important, but there are two important differences that you should be aware of:

1.  Doubles are approximations.
    Doubles represent floating point numbers that can not always be precisely represented with a fixed amount of memory.
    This means that you should consider all doubles to be approximations.
    For example, what is square of the square root of two?

    ```{r}
    x <- sqrt(2) ^ 2
    x
    x - 2
    ```

    This behaviour is common when working with floating point numbers: most calculations include some approximation error.
    Instead of comparing floating point numbers using `==`, you should use `dplyr::near()` which allows for some numerical tolerance.

2.  Integers have one special value: `NA`, while doubles have four: `NA`, `NaN`, `Inf` and `-Inf`.
    All three special values `NaN`, `Inf` and `-Inf` can arise during division:

    ```{r}
    c(-1, 0, 1) / 0
    ```

    Avoid using `==` to check for these other special values.
    Instead use the helper functions `is.finite()`, `is.infinite()`, and `is.nan()`:

    |                 | 0   | Inf | NA  | NaN |
    |-----------------|-----|-----|-----|-----|
    | `is.finite()`   | x   |     |     |     |
    | `is.infinite()` |     | x   |     |     |
    | `is.na()`       |     |     | x   | x   |
    | `is.nan()`      |     |     |     | x   |

### Character

Character vectors are the most complex type of atomic vector, because each element of a character vector is a string, and a string can contain an arbitrary amount of data.

You've already learned a lot about working with strings in [strings].
Here I wanted to mention one important feature of the underlying string implementation: R uses a global string pool.
This means that each unique string is only stored in memory once, and every use of the string points to that representation.
This reduces the amount of memory needed by duplicated strings.
You can see this behaviour in practice with `pryr::object_size()`:

```{r}
x <- "This is a reasonably long string."
pryr::object_size(x)

y <- rep(x, 1000)
pryr::object_size(y)
```

`y` doesn't take up 1,000x as much memory as `x`, because each element of `y` is just a pointer to that same string.
A pointer is 8 bytes, so 1000 pointers to a 152 B string is 8 \* 1000 + 152 = 8.14 kB.

### Missing values {#missing-values-vectors}

Note that each type of atomic vector has its own missing value:

```{r}
NA            # logical
NA_integer_   # integer
NA_real_      # double
NA_character_ # character
```

Normally you don't need to know about these different types because you can always use `NA` and it will be converted to the correct type using the implicit coercion rules described next.
However, there are some functions that are strict about their inputs, so it's useful to have this knowledge sitting in your back pocket so you can be specific when needed.

### Exercises

1.  Describe the difference between `is.finite(x)` and `!is.infinite(x)`.

2.  Read the source code for `dplyr::near()` (Hint: to see the source code, drop the `()`).
    How does it work?

3.  A logical vector can take 3 possible values.
    How many possible values can an integer vector take?
    How many possible values can a double take?
    Use google to do some research.

4.  Brainstorm at least four functions that allow you to convert a double to an integer.
    How do they differ?
    Be precise.

5.  What functions from the readr package allow you to turn a string into logical, integer, and double vector?

## Using atomic vectors

Now that you understand the different types of atomic vector, it's useful to review some of the important tools for working with them.
These include:

1.  How to convert from one type to another, and when that happens automatically.

2.  How to tell if an object is a specific type of vector.

3.  What happens when you work with vectors of different lengths.

4.  How to name the elements of a vector.

5.  How to pull out elements of interest.

### Coercion

There are two ways to convert, or coerce, one type of vector to another:

1.  Explicit coercion happens when you call a function like `as.logical()`, `as.integer()`, `as.double()`, or `as.character()`.
    Whenever you find yourself using explicit coercion, you should always check whether you can make the fix upstream, so that the vector never had the wrong type in the first place.
    For example, you may need to tweak your readr `col_types` specification.

2.  Implicit coercion happens when you use a vector in a specific context that expects a certain type of vector.
    For example, when you use a logical vector with a numeric summary function, or when you use a double vector where an integer vector is expected.

Because explicit coercion is used relatively rarely, and is largely easy to understand, I'll focus on implicit coercion here.

You've already seen the most important type of implicit coercion: using a logical vector in a numeric context.
In this case `TRUE` is converted to `1` and `FALSE` converted to `0`.
That means the sum of a logical vector is the number of trues, and the mean of a logical vector is the proportion of trues:

```{r}
x <- sample(20, 100, replace = TRUE)
y <- x > 10
sum(y)  # how many are greater than 10?
mean(y) # what proportion are greater than 10?
```

You may see some code (typically older) that relies on implicit coercion in the opposite direction, from integer to logical:

```{r, eval = FALSE}
if (length(x)) {
  # do something
}
```

In this case, 0 is converted to `FALSE` and everything else is converted to `TRUE`.
I think this makes it harder to understand your code, and I don't recommend it.
Instead be explicit: `length(x) > 0`.

It's also important to understand what happens when you try and create a vector containing multiple types with `c()`: the most complex type always wins.

```{r}
typeof(c(TRUE, 1L))
typeof(c(1L, 1.5))
typeof(c(1.5, "a"))
```

An atomic vector can not have a mix of different types because the type is a property of the complete vector, not the individual elements.
If you need to mix multiple types in the same vector, you should use a list, which you'll learn about shortly.

### Test functions

Sometimes you want to do different things based on the type of vector.
One option is to use `typeof()`.
Another is to use a test function which returns a `TRUE` or `FALSE`.
Base R provides many functions like `is.vector()` and `is.atomic()`, but they often return surprising results.
Instead, it's safer to use the `is_*` functions provided by purrr, which are summarised in the table below.

|                  | lgl | int | dbl | chr | list |
|------------------|-----|-----|-----|-----|------|
| `is_logical()`   | x   |     |     |     |      |
| `is_integer()`   |     | x   |     |     |      |
| `is_double()`    |     |     | x   |     |      |
| `is_numeric()`   |     | x   | x   |     |      |
| `is_character()` |     |     |     | x   |      |
| `is_atomic()`    | x   | x   | x   | x   |      |
| `is_list()`      |     |     |     |     | x    |
| `is_vector()`    | x   | x   | x   | x   | x    |

### Scalars and recycling rules

As well as implicitly coercing the types of vectors to be compatible, R will also implicitly coerce the length of vectors.
This is called vector **recycling**, because the shorter vector is repeated, or recycled, to the same length as the longer vector.

This is generally most useful when you are mixing vectors and "scalars".
I put scalars in quotes because R doesn't actually have scalars: instead, a single number is a vector of length 1.
Because there are no scalars, most built-in functions are **vectorised**, meaning that they will operate on a vector of numbers.
That's why, for example, this code works:

```{r}
sample(10) + 100
runif(10) > 0.5
```

In R, basic mathematical operations work with vectors.
That means that you should never need to perform explicit iteration when performing simple mathematical computations.

It's intuitive what should happen if you add two vectors of the same length, or a vector and a "scalar", but what happens if you add two vectors of different lengths?

```{r}
1:10 + 1:2
```

Here, R will expand the shortest vector to the same length as the longest, so called recycling.
This is silent except when the length of the longer is not an integer multiple of the length of the shorter:

```{r}
1:10 + 1:3
```

While vector recycling can be used to create very succinct, clever code, it can also silently conceal problems.
For this reason, the vectorised functions in tidyverse will throw errors when you recycle anything other than a scalar.
If you do want to recycle, you'll need to do it yourself with `rep()`:

```{r, error = TRUE}
tibble(x = 1:4, y = 1:2)

tibble(x = 1:4, y = rep(1:2, 2))

tibble(x = 1:4, y = rep(1:2, each = 2))
```

### Naming vectors

All types of vectors can be named.
You can name them during creation with `c()`:

```{r}
c(x = 1, y = 2, z = 4)
```

Or after the fact with `purrr::set_names()`:

```{r}
set_names(1:3, c("a", "b", "c"))
```

Named vectors are most useful for subsetting, described next.

### Subsetting {#vector-subsetting}

So far we've used `dplyr::filter()` to filter the rows in a tibble.
`filter()` only works with tibble, so we'll need a new tool for vectors: `[`.
`[` is the subsetting function, and is called like `x[a]`.
There are four types of things that you can subset a vector with:

1.  A numeric vector containing only integers.
    The integers must either be all positive, all negative, or zero.

    Subsetting with positive integers keeps the elements at those positions:

    ```{r}
    x <- c("one", "two", "three", "four", "five")
    x[c(3, 2, 5)]
    ```

    By repeating a position, you can actually make a longer output than input:

    ```{r}
    x[c(1, 1, 5, 5, 5, 2)]
    ```

    Negative values drop the elements at the specified positions:

    ```{r}
    x[c(-1, -3, -5)]
    ```

    It's an error to mix positive and negative values:

    ```{r, error = TRUE}
    x[c(1, -1)]
    ```

    The error message mentions subsetting with zero, which returns no values:

    ```{r}
    x[0]
    ```

    This is not useful very often, but it can be helpful if you want to create unusual data structures to test your functions with.

2.  Subsetting with a logical vector keeps all values corresponding to a `TRUE` value.
    This is most often useful in conjunction with the comparison functions.

    ```{r}
    x <- c(10, 3, NA, 5, 8, 1, NA)

    # All non-missing values of x
    x[!is.na(x)]

    # All even (or missing!) values of x
    x[x %% 2 == 0]
    ```

3.  If you have a named vector, you can subset it with a character vector:

    ```{r}
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    ```

    Like with positive integers, you can also use a character vector to duplicate individual entries.

4.  The simplest type of subsetting is nothing, `x[]`, which returns the complete `x`.
    This is not useful for subsetting vectors, but it is useful when subsetting matrices (and other high dimensional structures) because it lets you select all the rows or all the columns, by leaving that index blank.
    For example, if `x` is 2d, `x[1, ]` selects the first row and all the columns, and `x[, -1]` selects all rows and all columns except the first.

To learn more about the applications of subsetting, reading the "Subsetting" chapter of *Advanced R*: <http://adv-r.had.co.nz/Subsetting.html#applications>.

There is an important variation of `[` called `[[`.
`[[` only ever extracts a single element, and always drops names.
It's a good idea to use it whenever you want to make it clear that you're extracting a single item, as in a for loop.
The distinction between `[` and `[[` is most important for lists, as we'll see shortly.

### Exercises

1.  What does `mean(is.na(x))` tell you about a vector `x`?
    What about `sum(!is.finite(x))`?

2.  Carefully read the documentation of `is.vector()`.
    What does it actually test for?
    Why does `is.atomic()` not agree with the definition of atomic vectors above?

3.  Compare and contrast `setNames()` with `purrr::set_names()`.

4.  Create functions that take a vector as input and return:

    a.  The last value. Should you use `[` or `[[`?
    b.  The elements at even numbered positions.
    c.  Every element except the last value.
    d.  Only even numbers (and no missing values).

5.  Why is `x[-which(x > 0)]` not the same as `x[x <= 0]`?

6.  What happens when you subset with a positive integer that's bigger than the length of the vector?
    What happens when you subset with a name that doesn't exist?

## Recursive vectors (lists) {#lists}

Lists are a step up in complexity from atomic vectors, because lists can contain other lists.
This makes them suitable for representing hierarchical or tree-like structures.
You create a list with `list()`:

```{r}
x <- list(1, 2, 3)
x
```

A very useful tool for working with lists is `str()` because it focusses on the **str**ucture, not the contents.

```{r}
str(x)

x_named <- list(a = 1, b = 2, c = 3)
str(x_named)
```

Unlike atomic vectors, `list()` can contain a mix of objects:

```{r}
y <- list("a", 1L, 1.5, TRUE)
str(y)
```

Lists can even contain other lists!

```{r}
z <- list(list(1, 2), list(3, 4))
str(z)
```

### Visualising lists

To explain more complicated list manipulation functions, it's helpful to have a visual representation of lists.
For example, take these three lists:

```{r}
x1 <- list(c(1, 2), c(3, 4))
x2 <- list(list(1, 2), list(3, 4))
x3 <- list(1, list(2, list(3)))
```

I'll draw them as follows:

# ```{r, echo = FALSE, out.width = "75%"}
# knitr::include_graphics("diagrams/lists-structure.png")
# ```

There are three principles:

1.  Lists have rounded corners.
    Atomic vectors have square corners.

2.  Children are drawn inside their parent, and have a slightly darker background to make it easier to see the hierarchy.

3.  The orientation of the children (i.e. rows or columns) isn't important, so I'll pick a row or column orientation to either save space or illustrate an important property in the example.

### Subsetting

There are three ways to subset a list, which I'll illustrate with a list named `a`:

```{r}
a <- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
```

-   `[` extracts a sub-list.
    The result will always be a list.

    ```{r}
    str(a[1:2])
    str(a[4])
    ```

    Like with vectors, you can subset with a logical, integer, or character vector.

-   `[[` extracts a single component from a list.
    It removes a level of hierarchy from the list.

    ```{r}
    str(a[[1]])
    str(a[[4]])
    ```

-   `$` is a shorthand for extracting named elements of a list.
    It works similarly to `[[` except that you don't need to use quotes.

    ```{r}
    a$a
    a[["a"]]
    ```

The distinction between `[` and `[[` is really important for lists, because `[[` drills down into the list while `[` returns a new, smaller list.
Compare the code and output above with the visual representation in Figure \@ref(fig:lists-subsetting).

# ```{r lists-subsetting, echo = FALSE, out.width = "75%", fig.cap = "Subsetting a list, visually."}
# knitr::include_graphics("diagrams/lists-subsetting.png")
# ```

### Lists of condiments

The difference between `[` and `[[` is very important, but it's easy to get confused.
To help you remember, let me show you an unusual pepper shaker.

# ```{r, echo = FALSE, out.width = "25%"}
# knitr::include_graphics("images/pepper.jpg")
# ```

If this pepper shaker is your list `x`, then, `x[1]` is a pepper shaker containing a single pepper packet:

# ```{r, echo = FALSE, out.width = "25%"}
# knitr::include_graphics("images/pepper-1.jpg")
# ```

`x[2]` would look the same, but would contain the second packet.
`x[1:2]` would be a pepper shaker containing two pepper packets.

`x[[1]]` is:

<!-- ```{r, echo = FALSE, out.width = "25%"} -->
<!-- knitr::include_graphics("images/pepper-2.jpg") -->
<!-- ``` -->

If you wanted to get the content of the pepper package, you'd need `x[[1]][[1]]`:

# ```{r, echo = FALSE, out.width = "25%"}
# knitr::include_graphics("images/pepper-3.jpg")
# ```

### Exercises

1.  Draw the following lists as nested sets:

    a.  `list(a, b, list(c, d), list(e, f))`
    b.  `list(list(list(list(list(list(a))))))`

2.  What happens if you subset a tibble as if you're subsetting a list?
    What are the key differences between a list and a tibble?

## Attributes

Any vector can contain arbitrary additional metadata through its **attributes**.
You can think of attributes as named list of vectors that can be attached to any object.
You can get and set individual attribute values with `attr()` or see them all at once with `attributes()`.

```{r}
x <- 1:10
attr(x, "greeting")
attr(x, "greeting") <- "Hi!"
attr(x, "farewell") <- "Bye!"
attributes(x)
```

There are three very important attributes that are used to implement fundamental parts of R:

1.  **Names** are used to name the elements of a vector.
2.  **Dimensions** (dims, for short) make a vector behave like a matrix or array.
3.  **Class** is used to implement the S3 object oriented system.

You've seen names above, and we won't cover dimensions because we don't use matrices in this book.
It remains to describe the class, which controls how **generic functions** work.
Generic functions are key to object oriented programming in R, because they make functions behave differently for different classes of input.
A detailed discussion of object oriented programming is beyond the scope of this book, but you can read more about it in *Advanced R* at <http://adv-r.had.co.nz/OO-essentials.html#s3>.

Here's what a typical generic function looks like:

```{r}
as.Date
```

The call to "UseMethod" means that this is a generic function, and it will call a specific **method**, a function, based on the class of the first argument.
(All methods are functions; not all functions are methods).
You can list all the methods for a generic with `methods()`:

```{r}
methods("as.Date")
```

For example, if `x` is a character vector, `as.Date()` will call `as.Date.character()`; if it's a factor, it'll call `as.Date.factor()`.

You can see the specific implementation of a method with `getS3method()`:

```{r}
getS3method("as.Date", "default")
getS3method("as.Date", "numeric")
```

The most important S3 generic is `print()`: it controls how the object is printed when you type its name at the console.
Other important generics are the subsetting functions `[`, `[[`, and `$`.

## Augmented vectors

Atomic vectors and lists are the building blocks for other important vector types like factors and dates.
I call these **augmented vectors**, because they are vectors with additional **attributes**, including class.
Because augmented vectors have a class, they behave differently to the atomic vector on which they are built.
In this book, we make use of four important augmented vectors:

-   Factors
-   Dates
-   Date-times
-   Tibbles

These are described below.

### Factors

Factors are designed to represent categorical data that can take a fixed set of possible values.
Factors are built on top of integers, and have a levels attribute:

```{r}
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
attributes(x)
```

### Dates and date-times

Dates in R are numeric vectors that represent the number of days since 1 January 1970.

```{r}
x <- as.Date("1971-01-01")
unclass(x)

typeof(x)
attributes(x)
```

Date-times are numeric vectors with class `POSIXct` that represent the number of seconds since 1 January 1970.
(In case you were wondering, "POSIXct" stands for "Portable Operating System Interface", calendar time.)

```{r}
x <- lubridate::ymd_hm("1970-01-01 01:00")
unclass(x)

typeof(x)
attributes(x)
```

The `tzone` attribute is optional.
It controls how the time is printed, not what absolute time it refers to.

```{r}
attr(x, "tzone") <- "US/Pacific"
x

attr(x, "tzone") <- "US/Eastern"
x
```

There is another type of date-times called POSIXlt.
These are built on top of named lists:

```{r}
y <- as.POSIXlt(x)
typeof(y)
attributes(y)
```

POSIXlts are rare inside the tidyverse.
They do crop up in base R, because they are needed to extract specific components of a date, like the year or month.
Since lubridate provides helpers for you to do this instead, you don't need them.
POSIXct's are always easier to work with, so if you find you have a POSIXlt, you should always convert it to a regular date time with `lubridate::as_date_time()`.

### Tibbles

Tibbles are augmented lists: they have class "tbl_df" + "tbl" + "data.frame", and `names` (column) and `row.names` attributes:

```{r}
tb <- tibble::tibble(x = 1:5, y = 5:1)
typeof(tb)
attributes(tb)
```

The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length.
All functions that work with tibbles enforce this constraint.

Traditional data.frames have a very similar structure:

```{r}
df <- data.frame(x = 1:5, y = 5:1)
typeof(df)
attributes(df)
```

The main difference is the class.
The class of tibble includes "data.frame" which means tibbles inherit the regular data frame behaviour by default.

### Exercises

1.  What does `hms::hms(3600)` return?
    How does it print?
    What primitive type is the augmented vector built on top of?
    What attributes does it use?

2.  Try and make a tibble that has columns with different lengths.
    What happens?

3.  Based on the definition above, is it ok to have a list as a column of a tibble?


# Loops

Loops are R's method for repeating a task, which makes them a useful tool for programming simulations. This chapter will teach you how to use R's loop tools.

Let's use the `score` function to solve a real-world problem. 

Your slot machine is modeled after real machines that were accused of fraud. The machines appeared to pay out 40 cents on the dollar, but the manufacturer claimed that they paid out 92 cents on the dollar. You can calculate the exact payout rate of your machine with the `score` program. The payout rate will be the expected value of the slot machine's prize. 

## Expected Values

The expected value of a random event is a type of weighted average; it is the sum of each possible outcome of the event, weighted by the probability that each outcome occurs:

$$
E(x) = \sum_{i = 1}^{n}\left( x_{i} \cdot P(x_{i}) \right)
$$

You can think of the expected value as the average prize that you would observe if you played the slot machine an infinite number of times. Let's use the formula to calculate some simple expected values. Then we will apply the formula to your slot machine.

Do you remember the `die` you created in [Project 1: Weighted Dice]?

```r
die <- c(1, 2, 3, 4, 5, 6)
```

Each time you roll the die, it returns a value selected at random (one through six). You can find the expected value of rolling the die with the formula:

$$
E(\text{die}) = \sum_{i = 1}^{n}\left( \text{die}_{i} \cdot P(\text{die}_{i}) \right)
$$

The $\text{die}_{i}$s are the possible outcomes of rolling the die: 1, 2, 3, 4, 5, and 6; and the $P(\text{die}_{i})$'s are the probabilities associated with each of the outcomes. If your die is fair, each outcome will occur with the same probability: 1/6. So our equation simplifies to: 


$$
\begin{array}{rl}
E(\text{die}) & = \sum_{i = 1}^{n}\left( \text{die}_{i} \cdot P(\text{die}_{i}) \right)\\
& = 1 \cdot \frac{1}{6} +  2 \cdot \frac{1}{6} + 3 \cdot \frac{1}{6} + 4 \cdot \frac{1}{6} + 5 \cdot \frac{1}{6} + 6 \cdot \frac{1}{6}\\
& = 3.5\\
\end{array}
$$

Hence, the expected value of rolling a fair die is 3.5. You may notice that this is also the average value of the die. The expected value will equal the average if every outcome has the same chance of occurring. 

But what if each outcome has a different chance of occurring? For example, we weighted our dice in [Packages and Help Pages] so that each die rolled 1, 2, 3, 4, and 5 with probability 1/8 and 6 with probability 3/8. You can use the same formula to calculate the expected value in these conditions:

$$
\begin{array}{rl}
  E(die) & = 1 \cdot \frac{1}{8} +  2 \cdot \frac{1}{8} + 3 \cdot \frac{1}{8} + 4 \cdot \frac{1}{8} + 5 \cdot \frac{1}{8} + 6 \cdot \frac{3}{8}\\
  & = 4.125\\
  \end{array} 
$$

Hence, the expected value of a loaded die does not equal the average value of its outcomes. If you rolled a loaded die an infinite number of times, the average outcome would be 4.125, which is higher than what you would expect from a fair die.

Notice that we did the same three things to calculate both of these expected values. We have:

* Listed out all of the possible outcomes
* Determined the _value_ of each outcome (here just the value of the die)
* Calculated the probability that each outcome occurred

The expected value was then just the sum of the values in step 2 multiplied by the probabilities in step 3.

You can use these steps to calculate more sophisticated expected values. For example, you could calculate the expected value of rolling a pair of weighted dice. Let's do this step by step. 

First, list out all of the possible outcomes. A total of 36 different outcomes can appear when you roll two dice. For example, you might roll (1, 1), which notates one on the first die and one on the second die. Or, you may roll (1, 2), one on the first die and two on the second. And so on. Listing out these combinations can be tedious, but R has a function that can help.

## expand.grid

The `expand.grid` function in R provides a quick way to write out every combination of the elements in _n_ vectors. For example, you can list every combination of two dice. To do so, run `expand.grid` on two copies of `die`: 

```r
rolls <- expand.grid(die, die)
```

`expand.grid` will return a data frame that contains every way to pair an element from the first `die` vector with an element from the second `die` vector. This will capture all 36 possible combinations of values:

```r
rolls
##    Var1 Var2
## 1     1    1
## 2     2    1
## 3     3    1
## ...
## 34    4    6
## 35    5    6
## 36    6    6
```

You can use `expand.grid` with more than two vectors if you like. For example, you could list every combination of rolling three dice with `expand.grid(die, die, die)` and every combination of rolling four dice with `expand.grid(die, die, die, die)`, and so on. `expand.grid` will always return a data frame that contains each possible combination of _n_ elements from the _n_ vectors. Each combination will contain exactly one element from each vector.

You can determine the value of each roll once you've made your list of outcomes. This will be the sum of the two dice, which you can calculate using R's element-wise execution: 

```r
rolls$value <- rolls$Var1 + rolls$Var2
head(rolls, 3)
## Var1 Var2 value
##    1    1     2
##    2    1     3
##    3    1     4
```

R will match up the elements in each vector before adding them together. As a result, each element of `value` will refer to the elements of `Var1` and `Var2` that appear in the same row.

Next, you must determine the probability that each combination appears. You can calculate this with a basic rule of probability:

_The probability that_ n _independent, random events all occur is equal to the product of the probabilities that each random event occurs_. 

Or more succinctly:

$$
P(A \& B \& C \& ...) = P(A) \cdot P(B) \cdot P(C) \cdot ...
$$

So the probability that we roll a (1, 1) will be equal to the probability that we roll a one on the first die, 1/8, times the probability that we roll a one on the second die, 1/8:

$$
\begin{array}{rl}
P(1 \& 1) & = P(1) \cdot P(1) \\
& = \frac{1}{8} \cdot \frac{1}{8}\\
& = \frac{1}{64}
\end{array}
$$

And the probability that we roll a (1, 2) will be: 

$$
\begin{array}{rl}
P(1 \& 2) & = P(1) \cdot P(2) \\
& = \frac{1}{8} \cdot \frac{1}{8}\\
& = \frac{1}{64}
\end{array}
$$

And so on.

Let me suggest a three-step process for calculating these probabilities in R. First, we can look up the probabilities of rolling the values in `Var1`. We'll do this with the lookup table that follows: 

```r
prob <- c("1" = 1/8, "2" = 1/8, "3" = 1/8, "4" = 1/8, "5" = 1/8, "6" = 3/8)

prob
##     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.125 0.125 0.375 
```

If you subset this table by `rolls$Var1`, you will get a vector of probabilities perfectly keyed to the values of `Var1`:

```r
rolls$Var1
## 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6

prob[rolls$Var1]
##     1     2     3     4     5     6     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 
##     1     2     3     4     5     6     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 
##     1     2     3     4     5     6     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 

rolls$prob1 <- prob[rolls$Var1]
head(rolls, 3)
## Var1 Var2 value prob1
##    1    1     2 0.125
##    2    1     3 0.125
##    3    1     4 0.125
```

Second, we can look up the probabilities of rolling the values in `Var2`:

```r
rolls$prob2 <- prob[rolls$Var2]

head(rolls, 3)
## Var1 Var2 value prob1 prob2
##    1    1     2 0.125 0.125
##    2    1     3 0.125 0.125
##    3    1     4 0.125 0.125
```

Third, we can calculate the probability of rolling each combination by multiplying `prob1` by `prob2`:

```r
rolls$prob <- rolls$prob1 * rolls$prob2

head(rolls, 3)
## Var1 Var2 value prob1 prob2     prob
##    1    1     2 0.125 0.125 0.015625
##    2    1     3 0.125 0.125 0.015625
##    3    1     4 0.125 0.125 0.015625
```

It is easy to calculate the expected value now that we have each outcome, the value of each outcome, and the probability of each outcome. The expected value will be the summation of the dice values multiplied by the dice probabilities:

```r
sum(rolls$value * rolls$prob)
## 8.25
```

So the expected value of rolling two loaded dice is 8.25. If you rolled a pair of loaded dice an infinite number of times, the average sum would be 8.25. (If you are curious, the expected value of rolling a pair of fair dice is 7, which explains why 7 plays such a large role in dice games like craps.)

Now that you've warmed up, let's use our method to calculate the expected value of the slot machine prize. We will follow the same steps we just took: 

* We will list out every possible outcome of playing the machine. This will be a list of every combination of three slot symbols.
* We will calculate the probability of getting each combination when you play the machine.
* We will determine the prize that we would win for each combination.

When we are finished, we will have a data set that looks like this:

```r
## Var1 Var2 Var3 prob1 prob2 prob3     prob prize
##   DD   DD   DD  0.03  0.03  0.03 0.000027   800
##    7   DD   DD  0.03  0.03  0.03 0.000027     0
##  BBB   DD   DD  0.06  0.03  0.03 0.000054     0
## ... and so on.
```

The expected value will then be the sum of the prizes multiplied by their probability of occuring:

$$
E(\text{prize}) = \sum_{i = 1}^{n}\left( \text{prize}_{i} \cdot P(\text{prize}_{i}) \right)
$$

Ready to begin?

```{exercise, name = "List the Combinations"}
Use `expand.grid` to make a data frame that contains every possible combination of _three_ symbols from the `wheel` vector:
```

```r
wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
```

Be sure to add the argument `stringsAsFactors = FALSE` to your `expand.grid` call; otherwise, `expand.grid` will save the combinations as factors, an unfortunate choice that will disrupt the `score` function.

```{solution}
To create a data frame of each combination of _three_ symbols, you need to run `expand.grid` and give it _three_ copies of `wheel`. The result will be a data frame with 343 rows, one for each unique combination of three slot symbols:
```

```r
combos <- expand.grid(wheel, wheel, wheel, stringsAsFactors = FALSE)

combos
##   Var1 Var2 Var3
## 1   DD   DD   DD
## 2    7   DD   DD
## 3  BBB   DD   DD
## 4   BB   DD   DD
## 5    B   DD   DD
## 6    C   DD   DD
## ...
## 341    B    0    0
## 342    C    0    0
## 343    0    0    0
```

Now, let's calculate the probability of getting each combination. You can use the probabilities contained in the `prob` argument of `get_symbols` to do this. These probabilities determine how frequently each symbol is chosen when your slot machine generates symbols. They were calculated after observing 345 plays of the Manitoba video lottery terminals. Zeroes have the largest chance of being selected (0.52) and cherries the least (0.01):

```r
get_symbols <- function() {
  wheel <- c("DD", "7", "BBB", "BB", "B", "C", "0")
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52)
}
```


```{exercise, name = "Make a Lookup Table"}
Isolate the previous probabilities in a lookup table. What names will you use in your table?
```


```{solution}
Your names should match the input that you want to look up. In this case, the input will be the character strings that appear in `Var1`, `Var2`, and `Var3`. So your lookup table should look like this:
```

```r
prob <- c("DD" = 0.03, "7" = 0.03, "BBB" = 0.06, 
  "BB" = 0.1, "B" = 0.25, "C" = 0.01, "0" = 0.52)
```

Now let's look up our probabilities.

```{exercise, name = "Lookup the Probabilities"}
Look up the probabilities of getting the values in `Var1`. Then add them to `combos` as a column named `prob1`. Then do the same for `Var2` (`prob2`) and `Var3` (`prob3`). 
```


```{solution}
Remember that you use R's selection notation to look up values in a lookup table. The values that result will be keyed to the index that you use:
```

```r
combos$prob1 <- prob[combos$Var1]
combos$prob2 <- prob[combos$Var2]
combos$prob3 <- prob[combos$Var3]

head(combos, 3)
## Var1 Var2 Var3 prob1 prob2 prob3
##   DD   DD   DD  0.03  0.03  0.03
##    7   DD   DD  0.03  0.03  0.03
##  BBB   DD   DD  0.06  0.03  0.03
```

Now how should we calculate the total probability of each combination? Our three slot symbols are all chosen independently, which means that the same rule that governed our dice probabilities governs our symbol probabilities:

$$
P(A \& B \& C \& ...) = P(A) \cdot P(B) \cdot P(C) \cdot ...
$$

```{exercise, name = "Calculate Probabilities for Each Combination"}
Calculate the overall probabilities for each combination. Save them as a column named `prob` in `combos`, then check your work. 

You can check that the math worked by summing the probabilities. The probabilities should add up to one, because one of the combinations _must_ appear when you play the slot machine. In other words, a combination will appear, with probability of one.
```

You can calculate the probabilities of every possible combination in one fell swoop with some element-wise execution: 

```r
combos$prob <- combos$prob1 * combos$prob2 * combos$prob3

head(combos, 3)
## Var1 Var2 Var3 prob1 prob2 prob3     prob
##   DD   DD   DD  0.03  0.03  0.03 0.000027
##    7   DD   DD  0.03  0.03  0.03 0.000027
##  BBB   DD   DD  0.06  0.03  0.03 0.000054
```

The sum of the probabilities is one, which suggests that our math is correct:

```r
sum(combos$prob)
## 1
```

You only need to do one more thing before you can calculate the expected value: you must determine the prize for each combination in `combos`. You can calculate the prize with `score`. For example, we can calculate the prize for the first row of `combos` like this:

```r
symbols <- c(combos[1, 1], combos[1, 2], combos[1, 3])
## "DD" "DD" "DD"

score(symbols)
## 800
```

However there are 343 rows, which makes for tedious work if you plan to calculate the scores manually. It will be quicker to automate this task and have R do it for you, which you can do with a `for` loop.  
  

## for Loops

A `for` loop repeats a chunk of code many times, once for each element in a set of input. `for` loops provide a way to tell R, "Do this for every value of that." In R syntax, this looks like:

```r
for (value in that) {
  this
}
```

The `that` object should be a set of objects (often a vector of numbers or character strings). The for loop will run the code in that appears between the braces once for each member of `that`. For example, the for loop below runs `print("one run")` once for each element in a vector of character strings:

```r
for (value in c("My", "first", "for", "loop")) {
  print("one run")
}
## "one run"
## "one run"
## "one run"
## "one run"
```

The `value` symbol in a for loop acts like an argument in a function. The for loop will create an object named `value` and assign it a new value on each run of the loop. The code in your loop can access this value by calling the `value` object.

What values will the for loop assign to `value`? It will use the elements in the set that you run the loop on. `for` starts with the first element and then assigns a different element to `value` on each run of the for loop, until all of the elements have been assigned to `value`. For example, the for loop below will run `print(value)` four times and will print out one element of `c("My", "second", "for", "loop")` each time:

```r
for (value in c("My", "second", "for", "loop")) {
  print(value)
}
## "My"
## "second"
## "for"
## "loop"
```

On the first run, the for loop substituted `"My"` for `value` in `print(value)`. On the second run it substituted `"second"`, and so on until `for` had run `print(value)` once with every element in the set: 

If you look at `value` after the loop runs, you will see that it still contains the value of the last element in the set:

```r
value
## "loop"
```

I've been using the symbol `value` in my for loops, but there is nothing special about it. You can use any symbol you like in your loop to do the same thing as long as the symbol appears before `in` in the parentheses that follow `for`. For example, you could rewrite the previous loop with any of the following:

```r
for (word in c("My", "second", "for", "loop")) {
  print(word)
}
for (string in c("My", "second", "for", "loop")) {
  print(string)
}
for (i in c("My", "second", "for", "loop")) {
  print(i)
}
```

```{block2, type = "rmdwarning"}
**Choose your symbols carefully**
  
R will run your loop in whichever environment you call it from. This is bad news if your loop uses object names that already exist in the environment. Your loop will overwrite the existing objects with the objects that it creates. This applies to the value symbol as well.
```


```{block2, type = "rmdtip"}
**For loops run on sets**
  
In many programming languages, `for` loops are designed to work with integers, not sets. You give the loop a starting value and an ending value, as well as an increment to advance the value by between loops. The `for` loop then runs until the loop value exceeds the ending value. 

You can recreate this effect in R by having a `for` loop execute on a set of integers, but don't lose track of the fact that R's `for` loops execute on members of a set, not sequences of integers.
```

`for` loops are very useful in programming because they help you connect a piece of code with each element in a set. For example, we could use a `for` loop to run `score` once for each row in `combos`. However, R's `for` loops have a shortcoming that you'll want to know about before you start using them: `for` loops do not return output.

`for` loops are like Las Vegas: what happens in a `for` loop stays in a `for` loop. If you want to use the products of a `for` loop, you must write the `for` loop so that it saves its own output as it goes. 

Our previous examples appeared to return output, but this was misleading. The examples worked because we called `print`, which always prints its arguments in the console (even if it is called from a function, a `for` loop, or anything else). Our `for` loops won't return anything if you remove the `print` call:

```r
for (value in c("My", "third", "for", "loop")) {
  value
}
##
```

To save output from a `for` loop, you must write the loop so that it saves its own output as it runs. You can do this by creating an empty vector or list before you run the `for` loop. Then use the `for` loop to fill up the vector or list. When the `for` loop is finished, you'll be able to access the vector or list, which will now have all of your results.

Let's see this in action. The following code creates an empty vector of length 4:

```r
chars <- vector(length = 4)
```

The next loop will fill it with strings:

```r
words <- c("My", "fourth", "for", "loop")

for (i in 1:4) {
  chars[i] <- words[i]
}

chars
## "My"    "fourth" "for"   "loop"
```

This approach will usually require you to change the sets that you execute your `for` loop on. Instead of executing on a set of objects, execute on a set of integers that you can use to index both your object and your storage vector. This approach is very common in R. You'll find in practice that you use `for` loops not so much to run code, but to fill up vectors and lists with the results of code. 

Let's use a `for` loop to calculate the prize for each row in `combos`. To begin, create a new column in `combos` to store the results of the `for` loop:

```r
combos$prize <- NA

head(combos, 3)
##  Var1 Var2 Var3 prob1 prob2 prob3     prob prize
##    DD   DD   DD  0.03  0.03  0.03 0.000027    NA
##     7   DD   DD  0.03  0.03  0.03 0.000027    NA
##   BBB   DD   DD  0.06  0.03  0.03 0.000054    NA
```

The code creates a new column named prize and fills it with `NA`s. R uses its recycling rules to populate every value of the column with `NA`. 

```{exercise, name = "Build a Loop"}
Construct a `for` loop that will run `score` on all 343 rows of `combos`. The loop should run `score` on the first three entries of the _i_th row of `combos` and should store the results in the _i_th entry of `combos$prize`.
```

```{solution}
You can score the rows in `combos` with: 
```

```r
for (i in 1:nrow(combos)) {
  symbols <- c(combos[i, 1], combos[i, 2], combos[i, 3])
  combos$prize[i] <- score(symbols)
}
```

After you run the for loop, `combos$prize` will contain the correct prize for each row. This exercise also tests the `score` function; `score` appears to work correctly for every possible slot combination:

```r
head(combos, 3)
## Var1 Var2 Var3 prob1 prob2 prob3     prob prize
##   DD   DD   DD  0.03  0.03  0.03 0.000027   800
##    7   DD   DD  0.03  0.03  0.03 0.000027     0
##  BBB   DD   DD  0.06  0.03  0.03 0.000054     0
```

We're now ready to calculate the expected value of the prize. The expected value is the sum of `combos$prize` weighted by `combos$prob`. This is also the payout rate of the slot machine: 

```r
sum(combos$prize * combos$prob)
## 0.538014
```

Uh oh. The expected prize is about 0.54, which means our slot machine only pays 54 cents on the dollar over the long run. Does this mean that the manufacturer of the Manitoba slot machines _was_ lying?

No, because we ignored an important feature of the slot machine when we wrote `score`: a diamond is wild. You can treat a `DD` as any other symbol if it increases your prize, with one exception. You cannot make a `DD` a `C` unless you already have another `C` in your symbols (it'd be too easy if every `DD` automatically earned you $2). 

The best thing about `DD`s is that their effects are cumulative. For example, consider the combination `B`, `DD`, `B`. Not only does the `DD` count as a `B`, which would earn a prize of $10; the `DD` also doubles the prize to $20.

Adding this behavior to our code is a little tougher than what we have done so far, but it involves all of the same principles. You can decide that your slot machine doesn't use wilds and keep the code that we have. In that case, your slot machine will have a payout rate of about 54 percent. Or, you could rewrite your code to use wilds. If you do, you will find that your slot machine has a payout rate of 93 percent, one percent higher than the manufacturer's claim. You can calculate this rate with the same method that we used in this section.

```{exercise, name = "Challenge"}
There are many ways to modify `score` that would count `DD`s as wild. If you would like to test your skill as an R programmer, try to write your own version of `score` that correctly handles diamonds.

If you would like a more modest challenge, study the following `score` code. It accounts for wild diamonds in a way that I find elegant and succinct. See if you can understand each step in the code and how it achieves its result.
```


```{solution}
Here is a version of score that handles wild diamonds:
```

```r
score <- function(symbols) {
  
  diamonds <- sum(symbols == "DD")
  cherries <- sum(symbols == "C")
  
  # identify case
  # since diamonds are wild, only nondiamonds 
  # matter for three of a kind and all bars
  slots <- symbols[symbols != "DD"]
  same <- length(unique(slots)) == 1
  bars <- slots %in% c("B", "BB", "BBB")

  # assign prize
  if (diamonds == 3) {
    prize <- 100
  } else if (same) {
    payouts <- c("7" = 80, "BBB" = 40, "BB" = 25,
      "B" = 10, "C" = 10, "0" = 0)
    prize <- unname(payouts[slots[1]])
  } else if (all(bars)) {
    prize <- 5
  } else if (cherries > 0) {
    # diamonds count as cherries
    # so long as there is one real cherry
    prize <- c(0, 2, 5)[cherries + diamonds + 1]
  } else {
    prize <- 0
  }
  
  # double for each diamond
  prize * 2^diamonds
}
```


```{exercise, name = "Calculate the Expected Value"}
Calculate the expected value of the slot machine when it uses the new `score` function. You can use the existing `combos` data frame, but you will need to build a `for` loop to recalculate `combos$prize`.
```

To update the expected value, just update `combos$prize`:

```r
for (i in 1:nrow(combos)) {
  symbols <- c(combos[i, 1], combos[i, 2], combos[i, 3])
  combos$prize[i] <- score(symbols)
}
```

Then recompute the expected value:

```r
sum(combos$prize * combos$prob)
## 0.934356
```

This result vindicates the manufacturer's claim. If anything, the slot machines seem more generous than the manufacturer stated.

## while Loops

R has two companions to the `for` loop: the `while` loop and the `repeat` loop. A `while` loop reruns a chunk _while_ a certain condition remains `TRUE`. To create a `while` loop, follow `while` by a condition and a chunk of code, like this:

```r
while (condition) {
  code
}
```

`while` will rerun `condition`, which should be a logical test, at the start of each loop. If `condition` evaluates to `TRUE`, `while` will run the code between its braces. If `condition` evaluates to `FALSE`, `while` will finish the loop. 

Why might `condition` change from `TRUE` to `FALSE`? Presumably because the code inside your loop has changed whether the condition is still `TRUE`. If the code has no relationship to the condition, a `while` loop will run until you stop it. So be careful. You can stop a `while` loop by hitting Escape or by clicking on the stop-sign icon at the top of the RStudio console pane. The icon will appear once the loop begins to run.

Like `for` loops, `while` loops do not return a result, so you must think about what you want the loop to return and save it to an object during the loop.

You can use `while` loops to do things that take a varying number of iterations, like calculating how long it takes to go broke playing slots (as follows). However, in practice, `while` loops are much less common than `for` loops in R:

```r
plays_till_broke <- function(start_with) {
  cash <- start_with
  n <- 0
  while (cash > 0) {
    cash <- cash - 1 + play()
    n <- n + 1
  }
  n
}

plays_till_broke(100)
## 260
```

## repeat Loops

`repeat` loops are even more basic than `while` loops. They will repeat a chunk of code until you tell them to stop (by hitting Escape) or until they encounter the command `break`, which will stop the loop.

You can use a `repeat` loop to recreate `plays_till_broke`, my function that simulates how long it takes to lose money while playing slots: 

```r
plays_till_broke <- function(start_with) {
  cash <- start_with
  n <- 0
  repeat {
    cash <- cash - 1 + play()
    n <- n + 1
    if (cash <= 0) {
      break
    }
  }
  n
}

plays_till_broke(100)
## 237
```

## Summary

You can repeat tasks in R with `for`, `while`, and `repeat` loops. To use `for`, give it a chunk of code to run and a set of objects to loop through. `for` will run the code chunk once for each object. If you wish to save the output of your loop, you can assign it to an object that exists outside of the loop.

Repetition plays an important role in data science. It is the basis for simulation, as well as for estimates of variance and probability. Loops are not the only way to create repetition in R (consider `replicate` for example), but they are one of the most popular ways.

Unfortunately, loops in R can sometimes be slower than loops in other languages. As a result, R's loops get a bad rap. This reputation is not entirely deserved, but it does highlight an important issue. Speed is essential to data analysis. When your code runs fast, you can work with bigger data and do more to it before you run out of time or computational power. [Speed] will teach you how to write fast `for` loops and fast code in general with R. There, you will learn to write vectorized code, a style of lightning-fast code that takes advantage of all of R's strengths.